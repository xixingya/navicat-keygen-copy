#include "PatchSolutions.hpp"
#include <memory.h>

const uint8_t PatchSolution1::Keyword[0x188] = {
    0xfe, 0xfd, 0xfc, 0xf4, 0xfe, 0xd2, 0xf8, 0xf4, 0xf1, 0xd3, 0xde, 0xc7, 0xdf, 0xd3, 0xd0, 0xfd,
    0x8a, 0xc3, 0x85, 0xf4, 0xf6, 0xe9, 0xfc, 0xfc, 0xf2, 0xf5, 0xfa, 0xf5, 0xf6, 0xe9, 0x81, 0xfb,
    0xfe, 0xfd, 0xfc, 0xf4, 0xf4, 0xdf, 0xf2, 0xf9, 0xf2, 0xe5, 0xf0, 0xf7, 0xc0, 0x89, 0xdd, 0xcb,
    0xf5, 0x87, 0xe6, 0xdd, 0xf4, 0xd9, 0xf8, 0xfb, 0xde, 0xf9, 0xcf, 0xc5, 0x8f, 0x80, 0x80, 0xf3,
    0xc2, 0xd0, 0xe2, 0x8f, 0xfa, 0x8a, 0xdd, 0xf3, 0xd7, 0xdc, 0x86, 0xdc, 0xf0, 0x81, 0xc0, 0xea,
    0xd0, 0xd9, 0xf9, 0xd8, 0xda, 0xf2, 0xd0, 0xfd, 0xc3, 0xf6, 0xf3, 0x82, 0xf2, 0x81, 0xef, 0xf2,
    0xe0, 0xf9, 0xf2, 0xd3, 0x8f, 0xd7, 0xe9, 0xfb, 0xca, 0x86, 0xde, 0xfc, 0xf3, 0xd5, 0xdd, 0xf4,
    0xc7, 0x80, 0xf7, 0xd5, 0xf2, 0xc1, 0xde, 0xcc, 0xc0, 0xc7, 0xf0, 0xd0, 0xd0, 0xd1, 0xd7, 0xcc,
    0xd2, 0x81, 0xc1, 0x83, 0xdd, 0xd5, 0x8a, 0x8f, 0x81, 0xe1, 0xf4, 0xd9, 0xf3, 0xd7, 0xca, 0xef,
    0xf9, 0xdf, 0xe1, 0xee, 0xf0, 0xe9, 0xd1, 0xca, 0xf2, 0xe3, 0xf8, 0xf0, 0x83, 0xde, 0xfb, 0xd7,
    0xf1, 0xc4, 0xfa, 0x85, 0xf2, 0xdd, 0xdd, 0xfd, 0x85, 0x86, 0xc7, 0xf9, 0xc4, 0xc9, 0xf4, 0xf8,
    0xd4, 0xd9, 0xe6, 0xd2, 0xf6, 0xc1, 0xc1, 0xf9, 0xe0, 0xe4, 0xf7, 0xe4, 0xfd, 0xf1, 0xf6, 0xfc,
    0xe1, 0x84, 0xe4, 0xd1, 0xed, 0xfe, 0xdb, 0xe8, 0xdd, 0xe1, 0x85, 0xd0, 0xc5, 0xd2, 0x8a, 0x8e,
    0xd5, 0xdd, 0xe3, 0xdb, 0xd0, 0xe1, 0xd0, 0xf6, 0xc6, 0xee, 0xe6, 0xf7, 0xda, 0xf1, 0xdb, 0xc9,
    0x8b, 0xee, 0xcd, 0xdf, 0xff, 0xe8, 0xdd, 0xca, 0x82, 0xdb, 0xf1, 0x82, 0xc3, 0xed, 0xc9, 0xcc,
    0xc0, 0xf2, 0xd6, 0xdf, 0x83, 0xe9, 0xf3, 0xce, 0xea, 0xfa, 0xdf, 0xf8, 0xd9, 0xff, 0xec, 0x88,
    0xe4, 0xe4, 0xfd, 0x80, 0xc5, 0xce, 0xfa, 0xd2, 0xf4, 0xd8, 0x84, 0xff, 0xe5, 0xf3, 0xcb, 0xc2,
    0xfe, 0xc0, 0xc4, 0xfa, 0xde, 0xdd, 0xd5, 0xc9, 0xc5, 0xd5, 0xdf, 0xe3, 0xdd, 0xc1, 0xcb, 0xdd,
    0xfc, 0xf7, 0x83, 0xf8, 0xda, 0xc1, 0xd4, 0xe3, 0xfe, 0xc2, 0xef, 0xf8, 0xf2, 0xea, 0x8a, 0xd2,
    0xc7, 0xf2, 0xf0, 0xc2, 0xfb, 0x89, 0xdc, 0xeb, 0xd1, 0xf7, 0xcc, 0xe2, 0xd1, 0xfc, 0xd4, 0xce,
    0xea, 0xcd, 0xe4, 0x87, 0xe0, 0xcc, 0x8d, 0xf5, 0xc7, 0x85, 0x87, 0xda, 0xcf, 0xde, 0x89, 0xcd,
    0xe5, 0xfd, 0xe7, 0x83, 0xda, 0xdb, 0xfe, 0xf4, 0x84, 0xec, 0xf6, 0xee, 0xfd, 0xea, 0xf1, 0xf5,
    0xf5, 0xfc, 0xe6, 0xd0, 0x86, 0xdf, 0xc3, 0xe2, 0xe4, 0xd5, 0xd7, 0xe4, 0xe4, 0xce, 0xd4, 0xce,
    0x82, 0xda, 0xc7, 0xda, 0x80, 0xcb, 0xee, 0x8c, 0xd0, 0xde, 0xcd, 0xda, 0xdd, 0xcd, 0xcc, 0xeb,
    0xd2, 0xc3, 0xfc, 0xf2, 0xf6, 0xe9, 0xf8, 0xf8
};

PatchSolution1::PatchSolution1(const X64ImageInterpreter& Image) noexcept :
    pvt_Image(Image),
    pvt_PatchOffset(X64ImageInterpreter::InvalidOffset) {}

bool PatchSolution1::FindPatchOffset() noexcept {
    uint8_t* pbPatch = nullptr;

    for (size_t i = 0; i < pvt_Image.NumberOfSections(); ++i) {
        auto pbSectionView = pvt_Image.SectionView<uint8_t*>(i);
        auto cbSectiveView = pvt_Image.ImageSection(i)->size;

        if (cbSectiveView < sizeof(Keyword)) {
            continue;
        }

        for (size_t j = 0; j < cbSectiveView - sizeof(Keyword); ++j) {
            if (memcmp(pbSectionView + j, Keyword, sizeof(Keyword)) == 0) {
                pbPatch = pbSectionView + j;
                i = pvt_Image.NumberOfSections();
                break;
            }
        }
    }

    if (pbPatch == nullptr) {
        printf("[-] PatchSolution1 ...... Omitted.\n");
        return false;
    } else {
        pvt_PatchOffset = pbPatch - pvt_Image.ImageBase<uint8_t*>();

        printf("[+] PatchSolution1 ...... Ready to apply.\n");
        printf("    Keyword offset = +0x%.8x\n", pvt_PatchOffset);
        return true;
    }
}

bool PatchSolution1::CheckKey(const RSACipher& RsaCipher) const noexcept {
    try {
        std::string PublicKeyPEM = RsaCipher.ExportKeyString<RSAKeyType::PublicKey, RSAKeyFormat::PEM>();

        PublicKeyPEM.erase(PublicKeyPEM.find("-----BEGIN PUBLIC KEY-----"), 26);
        PublicKeyPEM.erase(PublicKeyPEM.find("-----END PUBLIC KEY-----"), 24);
        {
            std::string::size_type pos = 0;
            while ((pos = PublicKeyPEM.find('\n', pos)) != std::string::npos) {
                PublicKeyPEM.erase(pos, 1);
            }
        }

        return PublicKeyPEM.length() == sizeof(Keyword);
    } catch (...) {
        return false;
    }
}

void PatchSolution1::MakePatch(const RSACipher& RsaCipher) const {
    if (pvt_PatchOffset == X64ImageInterpreter::InvalidOffset) {
        // NOLINTNEXTLINE: allow exceptions that is not derived from std::exception
        throw nkg::Exception(__FILE__, __LINE__, "PatchSolution1 is not ready.");
    }

    auto pbPatch = pvt_Image.ImageOffset<uint8_t*>(pvt_PatchOffset);
    std::string PublicKeyPEM = RsaCipher.ExportKeyString<RSAKeyType::PublicKey, RSAKeyFormat::PEM>();

    PublicKeyPEM.erase(PublicKeyPEM.find("-----BEGIN PUBLIC KEY-----"), 26);
    PublicKeyPEM.erase(PublicKeyPEM.find("-----END PUBLIC KEY-----"), 24);
    {
        std::string::size_type pos = 0;
        while ((pos = PublicKeyPEM.find('\n', pos)) != std::string::npos) {
            PublicKeyPEM.erase(pos, 1);
        }
    }

    uint8_t key = 8;
    for (auto& c : PublicKeyPEM) {
        if (key == 0) key = 8;
        reinterpret_cast<uint8_t&>(c) ^= 0xbbu - key;
        --key;
    }

    puts("**************************************************************");
    puts("*                      PatchSolution1                        *");
    puts("**************************************************************");
    printf("@+0x%.8x\n", pvt_PatchOffset);

    puts("Previous:");
    nkg::PrintMemory(pbPatch, pbPatch + sizeof(Keyword), pbPatch);

    memcpy(pbPatch, PublicKeyPEM.data(), PublicKeyPEM.length());

    puts("After:");
    nkg::PrintMemory(pbPatch, pbPatch + sizeof(Keyword), pbPatch);

    puts("");
}

